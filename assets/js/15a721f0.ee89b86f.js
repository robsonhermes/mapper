(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[442],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return m},kt:function(){return c}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(n),c=o,h=u["".concat(p,".").concat(c)]||u[c]||d[c]||r;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5812:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var a=n(2122),o=n(9756),r=(n(7294),n(3905)),i={id:"introduce-to-automapper",title:"Introduce to AutoMapper",sidebar_label:"Introduce to AutoMapper"},l={unversionedId:"getting-started/introduce-to-automapper",id:"getting-started/introduce-to-automapper",isDocsHomePage:!1,title:"Introduce to AutoMapper",description:"Welcome to AutoMapper TypeScript! This basic tutorial will try to show you the problems that AutoMapper tries to solve with some basic functions that are included with @automapper/*",source:"@site/docs/getting-started/introduce-to-automapper.md",sourceDirName:"getting-started",slug:"/getting-started/introduce-to-automapper",permalink:"/docs/getting-started/introduce-to-automapper",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/getting-started/introduce-to-automapper.md",version:"current",sidebar_label:"Introduce to AutoMapper",frontMatter:{id:"introduce-to-automapper",title:"Introduce to AutoMapper",sidebar_label:"Introduce to AutoMapper"},sidebar:"docs",previous:{title:"Installation",permalink:"/docs/getting-started/installation"},next:{title:"Introduce to Profile",permalink:"/docs/getting-started/introduce-to-profile"}},p=[{value:"Before AutoMapper",id:"before-automapper",children:[]},{value:"Installing AutoMapper",id:"installing-automapper",children:[]},{value:"Create a <code>Mapper</code>",id:"create-a-mapper",children:[]},{value:"Decorating properties with <code>@AutoMap()</code> (for <code>classes</code> plugin only)",id:"decorating-properties-with-automap-for-classes-plugin-only",children:[]},{value:"Create a <code>Mapping&lt;User, UserDto&gt;</code>",id:"create-a-mappinguser-userdto",children:[]},{value:"Use the <code>Mapper</code>",id:"use-the-mapper",children:[]},{value:"Explanation of what happened",id:"explanation-of-what-happened",children:[{value:"<code>fullName</code> is missing",id:"fullname-is-missing",children:[]},{value:"<code>birthday</code> is missing",id:"birthday-is-missing",children:[]},{value:"<code>jobTitle</code> and <code>jobSalary</code> are <code>undefined</code>",id:"jobtitle-and-jobsalary-are-undefined",children:[]}]},{value:"How to fix",id:"how-to-fix",children:[{value:"Fixing <code>fullName</code>",id:"fixing-fullname",children:[]},{value:"Fixing <code>birthday</code>",id:"fixing-birthday",children:[]},{value:"Fixing <code>jobTitle</code> and <code>jobSalary</code>",id:"fixing-jobtitle-and-jobsalary",children:[]}]},{value:"Summary",id:"summary",children:[]}],s={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Welcome to AutoMapper TypeScript! This basic tutorial will try to show you the problems that AutoMapper tries to solve with some basic functions that are included with ",(0,r.kt)("inlineCode",{parentName:"p"},"@automapper/*")),(0,r.kt)("h2",{id:"before-automapper"},"Before AutoMapper"),(0,r.kt)("p",null,"Let's assume we have an application with a particular method to return some ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," information. Our application has the following models:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"User"),": the data of a user from the database"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UserDto"),": the shape of the user data that is exposed as the return type of this method")),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," will have a nested ",(0,r.kt)("inlineCode",{parentName:"p"},"Bio")," which also contains a nested ",(0,r.kt)("inlineCode",{parentName:"p"},"Job"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export class User {\n  firstName: string;\n  lastName: string;\n  username: string;\n  password: string;\n  bio: Bio;\n}\n\nexport class Bio {\n  job: Job;\n  birthday: Date;\n  avatarUrl: string;\n}\n\nexport class Job {\n  title: string;\n  salary: number;\n}\n")),(0,r.kt)("p",null,"The DTOs contain almost identical shapes as the Entities. Let's also assume we have some mapping logic on the DTOs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export class UserDto {\n  firstName: string;\n  lastName: string;\n  fullName: string;\n  username: string;\n  bio: BioDto;\n\n  static fromUser(user: User) {\n    const dto = new UserDto();\n    dto.firstName = user.firstName;\n    dto.lastName = user.lastName;\n    dto.fullName = user.firstName + ' ' + user.lastName;\n    dto.username = user.username;\n    dto.bio = BioDto.fromBio(user.bio);\n\n    return dto;\n  }\n}\n\nexport class BioDto {\n  jobTitle: string;\n  jobSalary: number;\n  birthday: string;\n  avatarUrl: string;\n\n  static fromBio(bio: Bio) {\n    const dto = new BioDto();\n    dto.jobTitle = bio.job.title;\n    dto.jobSalary = bio.job.salary;\n    dto.birthday = bio.birthday.toDateString();\n    dto.avatarUrl = bio.avatarUrl;\n\n    return dto;\n  }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function getUserDto(username: string): UserDto {\n  const user = fetchUserByUsernameFromDb(username);\n  return UserDto.fromUser(user);\n}\n")),(0,r.kt)("p",null,"Pretty straightforward, right? We fetch the user from the database then we call the static method on the ",(0,r.kt)("inlineCode",{parentName:"p"},"UserDto")," to ",(0,r.kt)("em",{parentName:"p"},"transform")," a ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"UserDto")," then return it. Short and sweet, the code looks clean too."),(0,r.kt)("p",null,"However, there are a couple of problems with the above approach:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It is not ",(0,r.kt)("strong",{parentName:"li"},"scalable"),". For each of the transformations from some models (let's call these ",(0,r.kt)("strong",{parentName:"li"},"Source"),") to ",(0,r.kt)("inlineCode",{parentName:"li"},"UserDto"),", we're going to have to write a static method ",(0,r.kt)("inlineCode",{parentName:"li"},"static from*()"),". The properties with the same name as the ",(0,r.kt)("strong",{parentName:"li"},"Source")," will have to be repeated over and over in each ",(0,r.kt)("inlineCode",{parentName:"li"},"static from*()")," method. Granted, we can create some reusable function but what if we add more properties to the models?"),(0,r.kt)("li",{parentName:"ul"},"It is not ",(0,r.kt)("strong",{parentName:"li"},"maintainable"),". We introduce some tight-coupling. Now ",(0,r.kt)("inlineCode",{parentName:"li"},"UserDto")," needs to know about ",(0,r.kt)("inlineCode",{parentName:"li"},"User"),". Same thing applies to ",(0,r.kt)("inlineCode",{parentName:"li"},"BioDto")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Bio"),". What if we have our models ",(0,r.kt)("inlineCode",{parentName:"li"},"extends")," some other models? The complexity will increase.")),(0,r.kt)("p",null,"Let's see how AutoMapper can help"),(0,r.kt)("h2",{id:"installing-automapper"},"Installing AutoMapper"),(0,r.kt)("p",null,"Start by installing the dependencies"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm i @automapper/{core,classes}\nnpm i -D @automapper/types\n\n# or with yarn\nyarn add @automapper/{core,classes}\nyarn add -D @automapper/types\n")),(0,r.kt)("h2",{id:"create-a-mapper"},"Create a ",(0,r.kt)("inlineCode",{parentName:"h2"},"Mapper")),(0,r.kt)("p",null,"In some separate file called ",(0,r.kt)("inlineCode",{parentName:"p"},"mapper.ts"),", we will start initializing our ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapper")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { createMapper } from '@automapper/core';\nimport { classes } from '@automapper/classes';\n\nexport const mapper = createMapper({\n  name: 'someName',\n  pluginInitializer: classes,\n});\n")),(0,r.kt)("h2",{id:"decorating-properties-with-automap-for-classes-plugin-only"},"Decorating properties with ",(0,r.kt)("inlineCode",{parentName:"h2"},"@AutoMap()")," (for ",(0,r.kt)("inlineCode",{parentName:"h2"},"classes")," plugin only)"),(0,r.kt)("p",null,"Let's bring our models here once again"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { AutoMap } from '@automapper/classes';\n\nexport class User {\n  @AutoMap()\n  firstName: string;\n\n  @AutoMap()\n  lastName: string;\n\n  @AutoMap()\n  username: string;\n\n  password: string;\n\n  @AutoMap({ typeFn: () => Bio })\n  bio: Bio;\n}\n\nexport class Bio {\n  @AutoMap({ typeFn: () => Job })\n  job: Job;\n\n  birthday: Date;\n\n  @AutoMap()\n  avatarUrl: string;\n}\n\nexport class Job {\n  @AutoMap()\n  title: string;\n\n  @AutoMap()\n  salary: number;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { AutoMap } from '@automapper/classes';\n\nexport class UserDto {\n  @AutoMap()\n  firstName: string;\n\n  @AutoMap()\n  lastName: string;\n\n  fullName: string; // <- we purposely left this one out\n\n  @AutoMap()\n  username: string;\n\n  @AutoMap({ typeFn: () => BioDto })\n  bio: BioDto;\n}\n\nexport class BioDto {\n  @AutoMap()\n  jobTitle: string;\n\n  @AutoMap()\n  jobSalary: number;\n\n  birthday: string; // <- we purposely left this one out\n\n  @AutoMap()\n  avatarUrl: string;\n}\n")),(0,r.kt)("p",null,"We did the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Removed the mapping logic in the DTOs"),(0,r.kt)("li",{parentName:"ul"},"Decorated all the properties with the same name with ",(0,r.kt)("inlineCode",{parentName:"li"},"@AutoMap()"),". For nested model like ",(0,r.kt)("inlineCode",{parentName:"li"},"BioDto"),", we provide a ",(0,r.kt)("inlineCode",{parentName:"li"},"typeFn")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"@AutoMap()"))),(0,r.kt)("h2",{id:"create-a-mappinguser-userdto"},"Create a ",(0,r.kt)("inlineCode",{parentName:"h2"},"Mapping<User, UserDto>")),(0,r.kt)("p",null,"We've prepped our models with ",(0,r.kt)("inlineCode",{parentName:"p"},"@AutoMap()"),", it is time to create the mappings. The mappings are created once and can be separated from the rest of other business logic code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"mapper.createMap(Bio, BioDto);\nmapper.createMap(User, UserDto);\n")),(0,r.kt)("h2",{id:"use-the-mapper"},"Use the ",(0,r.kt)("inlineCode",{parentName:"h2"},"Mapper")),(0,r.kt)("p",null,"Now our ",(0,r.kt)("inlineCode",{parentName:"p"},"getUserDto()")," method will look like the following"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function getUserDto(username: string): UserDto {\n  const user = fetchUserByUsernameFromDb(username);\n  return mapper.map(user, UserDto, User);\n}\n")),(0,r.kt)("p",null,"Unfortunately, our ",(0,r.kt)("inlineCode",{parentName:"p"},"UserDto")," is missing some information"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const dto = {\n  firstName: 'Chau',\n  lastName: 'Tran',\n  username: 'ctran',\n  bio: {\n    jobTitle: undefined,\n    jobSalary: undefined,\n    avatarUrl: 'url.com',\n  },\n};\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bio.birthday")," are nowhere to be found. ",(0,r.kt)("inlineCode",{parentName:"p"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jobSalary")," are ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),". There is also a ",(0,r.kt)("inlineCode",{parentName:"p"},"console.error")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Unmapped properties:\n-------------------\njobTitle,\njobSalary\n")),(0,r.kt)("p",null,'On the bright side, we can see that the properties, that are matching, are "auto-mapped" correctly. The nested model ',(0,r.kt)("inlineCode",{parentName:"p"},"bio")," is also mapped which is a good sign."),(0,r.kt)("h2",{id:"explanation-of-what-happened"},"Explanation of what happened"),(0,r.kt)("h3",{id:"fullname-is-missing"},(0,r.kt)("inlineCode",{parentName:"h3"},"fullName")," is missing"),(0,r.kt)("p",null,"On our ",(0,r.kt)("inlineCode",{parentName:"p"},"UserDto"),", we have a property called ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," and we did not decorate it with ",(0,r.kt)("inlineCode",{parentName:"p"},"@AutoMap()"),". Without ",(0,r.kt)("inlineCode",{parentName:"p"},"@AutoMap()"),", AutoMapper does not have any information about this ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," property on the ",(0,r.kt)("inlineCode",{parentName:"p"},"UserDto"),". If we were to put ",(0,r.kt)("inlineCode",{parentName:"p"},"@AutoMap()")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," and re-execute our ",(0,r.kt)("inlineCode",{parentName:"p"},"getUserDto()")," method, we would then get ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName: undefined"),"."),(0,r.kt)("p",null,"The reason is our ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," does not have a ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," property. In other words, we can think of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserDto.fullName")," as a computed property. AutoMap cannot ",(0,r.kt)("em",{parentName:"p"},"auto")," configure computed properties."),(0,r.kt)("h3",{id:"birthday-is-missing"},(0,r.kt)("inlineCode",{parentName:"h3"},"birthday")," is missing"),(0,r.kt)("p",null,"Same reason as ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName"),". We did not decorate ",(0,r.kt)("inlineCode",{parentName:"p"},"birthday")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"@AutoMap()"),". The difference here is that on ",(0,r.kt)("inlineCode",{parentName:"p"},"Bio"),", we also have ",(0,r.kt)("inlineCode",{parentName:"p"},"birthday")," field. The problem is ",(0,r.kt)("inlineCode",{parentName:"p"},"Bio.birthday")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BioDto.birthday")," have different data types (",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," vs ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),")."),(0,r.kt)("p",null,"AutoMapper isn't smart enough to read the consumers' mind on how they want to map from a ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," to a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," (even though AutoMapper does have information about each field's data type in most cases)."),(0,r.kt)("h3",{id:"jobtitle-and-jobsalary-are-undefined"},(0,r.kt)("inlineCode",{parentName:"h3"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"jobSalary")," are ",(0,r.kt)("inlineCode",{parentName:"h3"},"undefined")),(0,r.kt)("p",null,"Same reason as above, we decorated ",(0,r.kt)("inlineCode",{parentName:"p"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jobSalary")," so they will be added to the metadata list of ",(0,r.kt)("inlineCode",{parentName:"p"},"BioDto")," but on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Bio"),", we do not have ",(0,r.kt)("inlineCode",{parentName:"p"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jobSalary"),"."),(0,r.kt)("p",null,"The difference between ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jobTitle")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"jobSalary"),") is that ",(0,r.kt)("inlineCode",{parentName:"p"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jobSalary")," are flatten properties of ",(0,r.kt)("inlineCode",{parentName:"p"},"job: Job")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"jobTitle")," vs ",(0,r.kt)("inlineCode",{parentName:"li"},"job.title")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"jobSalary")," vs ",(0,r.kt)("inlineCode",{parentName:"li"},"job.salary"))),(0,r.kt)("h2",{id:"how-to-fix"},"How to fix"),(0,r.kt)("p",null,"To fix ",(0,r.kt)("inlineCode",{parentName:"p"},"fullName")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"birthday"),", we are going to tap into the Mapping Configuration portion of AutoMapper, which is quite powerful. For ",(0,r.kt)("inlineCode",{parentName:"p"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jobSalary"),", we will utilize ",(0,r.kt)("strong",{parentName:"p"},"Flattening")," capability with ",(0,r.kt)("a",{parentName:"p",href:"/docs/fundamentals#namingconvention"},"NamingConvention")),(0,r.kt)("p",null,"Let's remind every one of our Mapping creation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"mapper.createMap(Bio, BioDto);\nmapper.createMap(User, UserDto);\n")),(0,r.kt)("h3",{id:"fixing-fullname"},"Fixing ",(0,r.kt)("inlineCode",{parentName:"h3"},"fullName")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"mapper.createMap(User, UserDto).forMember(\n  (destination) => destination.fullName,\n  mapFrom((source) => source.firstName + ' ' + source.lastName)\n);\n")),(0,r.kt)("p",null,"We call ",(0,r.kt)("inlineCode",{parentName:"p"},"forMember()")," after ",(0,r.kt)("inlineCode",{parentName:"p"},"createMap()"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"forMember()")," knows what two models it is being called upon. In this case, those are ",(0,r.kt)("inlineCode",{parentName:"li"},"User")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"UserDto")),(0,r.kt)("li",{parentName:"ul"},"We pass in a Property Selector for ",(0,r.kt)("inlineCode",{parentName:"li"},"forMember()")," first argument. Because ",(0,r.kt)("inlineCode",{parentName:"li"},"forMember()")," knows about the models, it will have intellisense of what ",(0,r.kt)("inlineCode",{parentName:"li"},"destination")," is"),(0,r.kt)("li",{parentName:"ul"},"We pass in a ",(0,r.kt)("inlineCode",{parentName:"li"},"MemberMapFunction")," for ",(0,r.kt)("inlineCode",{parentName:"li"},"forMember()")," second argument. Here, we provide an instruction of how we want to map ",(0,r.kt)("inlineCode",{parentName:"li"},"destination.fullName"),'. We said: "For ',(0,r.kt)("inlineCode",{parentName:"li"},"destination.fullName"),", please ",(0,r.kt)("inlineCode",{parentName:"li"},"mapFrom")," ",(0,r.kt)("inlineCode",{parentName:"li"},"source.firstName")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"source.lastName"),'"')),(0,r.kt)("h3",{id:"fixing-birthday"},"Fixing ",(0,r.kt)("inlineCode",{parentName:"h3"},"birthday")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"mapper.createMap(Bio, BioDto).forMember(\n  (destination) => destination.birthday,\n  mapFrom((source) => source.birthday.toDateString())\n);\n")),(0,r.kt)("p",null,'Same concept as above. We said: "For ',(0,r.kt)("inlineCode",{parentName:"p"},"destination.birthday"),", please ",(0,r.kt)("inlineCode",{parentName:"p"},"mapFrom")," ",(0,r.kt)("inlineCode",{parentName:"p"},"source.birthday.toDateString()"),'"'),(0,r.kt)("h3",{id:"fixing-jobtitle-and-jobsalary"},"Fixing ",(0,r.kt)("inlineCode",{parentName:"h3"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"jobSalary")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"jobSalary")," are on ",(0,r.kt)("inlineCode",{parentName:"p"},"BioDto")," so we're going to reuse the mapping configuration from the above"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { CamelCaseNamingConvention } from '@automapper/core';\n\nmapper\n  .createMap(Bio, BioDto, {\n    namingConventions: {\n      source: new CamelCaseNamingConvention(),\n      destination: new CamelCaseNamingConvention(),\n    },\n  })\n  .forMember(\n    (destination) => destination.birthday,\n    mapFrom((source) => source.birthday.toDateString())\n  );\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"mapper.createMap")," accepts an optional third argument ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateMapOptions")," where we can provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"namingConventions")," object with ",(0,r.kt)("inlineCode",{parentName:"p"},"source")," convention and ",(0,r.kt)("inlineCode",{parentName:"p"},"destination")," convention. Here, we provide ",(0,r.kt)("inlineCode",{parentName:"p"},"CamelCaseNamingConvention")," for both. With ",(0,r.kt)("a",{parentName:"p",href:"/docs/fundamentals#namingconvention"},"NamingConvention"),", AutoMapper has enough information to apply basic ",(0,r.kt)("strong",{parentName:"p"},"Flattening")," to the mapping."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"namingConventions")," can also take in a single ",(0,r.kt)("inlineCode",{parentName:"p"},"NamingConvention")," if both models use the same ",(0,r.kt)("inlineCode",{parentName:"p"},"NamingConvention"),"."),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"mapper.createMap(Bio, BioDto, {\n  namingConventions: new CamelCaseNamingConvention(),\n});\n"))),(0,r.kt)("p",null,"Let's re-execute ",(0,r.kt)("inlineCode",{parentName:"p"},"getUserDto()")," and we will now see a complete ",(0,r.kt)("inlineCode",{parentName:"p"},"UserDto")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "firstName": "Chau",\n  "lastName": "Tran",\n  "username": "ctran",\n  "bio": {\n    "jobTitle": "Developer",\n    "jobSalary": 123456,\n    "avatarUrl": "url.com",\n    "birthday": "Sat Jan 02 2021"\n  },\n  "fullName": "Chau Tran"\n}\n')),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Without AutoMapper, our mapping logic is not maintainable and scalable. We have tight coupling between DTOs and Entities."),(0,r.kt)("li",{parentName:"ul"},"AutoMapper brings ",(0,r.kt)("strong",{parentName:"li"},"Separation of Concern")," and ",(0,r.kt)("strong",{parentName:"li"},"Conventions over Configuration")," to our mapping logic.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"firstName"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"lastName"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"username"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"bio")," are ",(0,r.kt)("em",{parentName:"li"},"auto-mapped")," correctly"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"jobTitle")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"jobSalary")," are ",(0,r.kt)("em",{parentName:"li"},"flatten")," and ",(0,r.kt)("em",{parentName:"li"},"auto-mapped")," correctly with ",(0,r.kt)("a",{parentName:"li",href:"/docs/fundamentals#namingconvention"},"NamingConvention")))),(0,r.kt)("li",{parentName:"ul"},"Mapping Configuration is powerful and highly customizable. ",(0,r.kt)("inlineCode",{parentName:"li"},"fullName")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"birthday")," are some of the simplest examples of what Mapping Configuration can provide."),(0,r.kt)("li",{parentName:"ul"},"There are some gotchas:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Order of Mapping matters. Because ",(0,r.kt)("inlineCode",{parentName:"li"},"Bio")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"BioDto")," are nested models of ",(0,r.kt)("inlineCode",{parentName:"li"},"User")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"UserDto"),", we create their Mapping first."),(0,r.kt)("li",{parentName:"ul"},"Verbosity with ",(0,r.kt)("inlineCode",{parentName:"li"},"@AutoMap()")," decorator. This is required although for properties that are manually configured with Mapping Configuration, ",(0,r.kt)("inlineCode",{parentName:"li"},"@AutoMap()")," isn't required."))),(0,r.kt)("li",{parentName:"ul"},"Here's the full code:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { AutoMap } from '@automapper/classes';\n\nexport class User {\n  @AutoMap()\n  firstName: string;\n\n  @AutoMap()\n  lastName: string;\n\n  @AutoMap()\n  username: string;\n\n  password: string;\n\n  @AutoMap({ typeFn: () => Bio })\n  bio: Bio;\n}\n\nexport class Bio {\n  @AutoMap({ typeFn: () => Job })\n  job: Job;\n\n  birthday: Date;\n\n  @AutoMap()\n  avatarUrl: string;\n}\n\nexport class Job {\n  @AutoMap()\n  title: string;\n\n  @AutoMap()\n  salary: number;\n}\n\nexport class UserDto {\n  @AutoMap()\n  firstName: string;\n\n  @AutoMap()\n  lastName: string;\n\n  fullName: string;\n\n  @AutoMap()\n  username: string;\n\n  @AutoMap({ typeFn: () => BioDto })\n  bio: BioDto;\n}\n\nexport class BioDto {\n  @AutoMap()\n  jobTitle: string;\n\n  @AutoMap()\n  jobSalary: number;\n\n  birthday: string;\n\n  @AutoMap()\n  avatarUrl: string;\n}\n\nmapper\n  .createMap(Bio, BioDto, {\n    namingConventions: {\n      source: new CamelCaseNamingConvention(),\n      destination: new CamelCaseNamingConvention(),\n    },\n  })\n  .forMember(\n    (destination) => destination.birthday,\n    mapFrom((source) => source.birthday.toDateString())\n  );\n\nmapper.createMap(User, UserDto).forMember(\n  (destination) => destination.fullName,\n  mapFrom((source) => source.firstName + ' ' + source.lastName)\n);\n\nfunction getUserDto(username: string): UserDto {\n  const user = fetchUserByUsernameFromDb(username);\n  return mapper.map(user, UserDto, User);\n}\n")))}m.isMDXComponent=!0}}]);