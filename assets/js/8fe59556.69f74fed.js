(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[510],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=s(n),d=a,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1577:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return p},toc:function(){return l},default:function(){return c}});var r=n(2122),a=n(9756),i=(n(7294),n(3905)),o={id:"technical",title:"Technical Difficulties",sidebar_label:"Technical difficulties"},p={unversionedId:"introduction/technical",id:"introduction/technical",isDocsHomePage:!1,title:"Technical Difficulties",description:"Problems with TypeScript",source:"@site/docs/introduction/technical-difficulties.md",sourceDirName:"introduction",slug:"/introduction/technical",permalink:"/docs/introduction/technical",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/introduction/technical-difficulties.md",version:"current",sidebar_label:"Technical difficulties",frontMatter:{id:"technical",title:"Technical Difficulties",sidebar_label:"Technical difficulties"},sidebar:"docs",previous:{title:"What and why?",permalink:"/docs/introduction/what-why"},next:{title:"Alternatives",permalink:"/docs/introduction/alternatives"}},l=[{value:"Problems with TypeScript",id:"problems-with-typescript",children:[]},{value:"Asynchronous",id:"asynchronous",children:[{value:"&quot;Fake&quot; Async",id:"fake-async",children:[]},{value:"Why not &quot;real&quot;?",id:"why-not-real",children:[]},{value:"Help needed",id:"help-needed",children:[]}]}],s={toc:l};function c(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"problems-with-typescript"},"Problems with TypeScript"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Reflection_(computer_programming)"},"Reflection")," plays a huge part in the ",(0,i.kt)("em",{parentName:"p"},"auto")," portion of an AutoMapper implementation. It is especially ",(0,i.kt)("em",{parentName:"p"},"not that great")," in TypeScript. Let's take a look at the following snippet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"class User {\n  firstName: string;\n  lastName: string;\n}\n")),(0,i.kt)("p",null,"the above ",(0,i.kt)("inlineCode",{parentName:"p"},".ts")," code will be compiled to the following in ",(0,i.kt)("inlineCode",{parentName:"p"},".js")," (depending on the ",(0,i.kt)("strong",{parentName:"p"},"JS")," flavor you picked for your ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class User {}\n\n// or in older ES\nfunction User() {}\n")),(0,i.kt)("p",null,"Now, when you try to ",(0,i.kt)("inlineCode",{parentName:"p"},"instantiate")," (or ",(0,i.kt)("inlineCode",{parentName:"p"},"new up"),") a ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," by writing the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const user = new User();\nconsole.log(user);\n")),(0,i.kt)("p",null,"You would expect to get ",(0,i.kt)("inlineCode",{parentName:"p"},"User { firstName: undefined, lastName: undefined }")," printed out to the console, wouldn't you? At least, it was my expectation. In reality, you would get ",(0,i.kt)("inlineCode",{parentName:"p"},"User {}")," without any information regarding ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName"),". Next, let's take a look at some similar snippets in ",(0,i.kt)("strong",{parentName:"p"},"C#"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// SomeFileName.cs\n\n// Same Domain model as in TypeScript\nclass User {\n    public string FirstName {get; set;}\n    public string LastName {get; set;}\n    // ... some additional properties ...\n}\n\n// Some ViewModel class\nclass UserVm {\n    public string FirstName {get; set;}\n    public string LastName {get; set;}\n    // ... some additional properties ...\n}\n\n...\n// Create the Mapping between User and UserVm\nCreateMap<User, UserVm>();\n...\n\n...\n// Actual map from User to UserVm\nvar userVm = Mapper.Map<UserVm>(user);\n...\n")),(0,i.kt)("p",null,"In C#, AutoMapper will be able to ",(0,i.kt)("em",{parentName:"p"},"conventionally map")," ",(0,i.kt)("inlineCode",{parentName:"p"},"User.FirstName")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"UserVm.FirstName")," because of conventions. The two classes share the same property names. In TypeScript, you cannot do that ",(0,i.kt)("strong",{parentName:"p"},"without")," having to do a bit extra work. The ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," (or ",(0,i.kt)("inlineCode",{parentName:"p"},"UserVm"),") instance in TypeScript does not contain any properties because we ",(0,i.kt)("em",{parentName:"p"},"never actually declared")," them in the class. If you are interested in learning more about this whole process, read my ",(0,i.kt)("a",{parentName:"p",href:"https://nartc.netlify.com/blogs/automapper-typescript/"},"blog post"),"."),(0,i.kt)("h2",{id:"asynchronous"},"Asynchronous"),(0,i.kt)("h3",{id:"fake-async"},'"Fake" Async'),(0,i.kt)("p",null,"You will probably run into some ",(0,i.kt)("strong",{parentName:"p"},"async")," variations like ",(0,i.kt)("inlineCode",{parentName:"p"},"mapAsync()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mapArrayAsync()"),". Those are ",(0,i.kt)("em",{parentName:"p"},"fake async"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"mapAsync()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mapArrayAsync()")," are wrapped inside a ",(0,i.kt)("inlineCode",{parentName:"p"},"resolved Promise")," so that if you ever need an async version (maybe some of your APIs need to expect ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise"),", or you use ",(0,i.kt)("inlineCode",{parentName:"p"},"afterMap()")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"async"),"), you'll have those at your disposal."),(0,i.kt)("p",null,"Let's look at the following snippet:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"mapAsync(...args: any[]) { // simplified for brevity\n    return Promise.resolve().then(() => map(...args));\n}\n\nmapArrayAsync(...args: any[]) {\n    return Promise.resolve().then(() => mapArray(...args));\n}\n")),(0,i.kt)("p",null,"Those are the exact implementations of ",(0,i.kt)("inlineCode",{parentName:"p"},"mapAsync")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mapArrayAsync")),(0,i.kt)("h3",{id:"why-not-real"},'Why not "real"?'),(0,i.kt)("p",null,"Real async support can be provided by utilizing Worker (aka. Worker Thread for NodeJS and Web Worker on the Browser). However, most of the mapping configurations in ",(0,i.kt)("inlineCode",{parentName:"p"},"@automapper/core")," are lazily-evaluated functions that are used to be invoked later. These functions are termed ",(0,i.kt)("inlineCode",{parentName:"p"},"MemberMapFunction")," in the context of ",(0,i.kt)("inlineCode",{parentName:"p"},"@automapper/core"),". The consumers would define these functions at configuration time then they will be invoked later at mapping time. Thus, a mapping operation ",(0,i.kt)("strong",{parentName:"p"},"cannot")," have its arguments ",(0,i.kt)("em",{parentName:"p"},"serialized")," to be sent to the Worker thread."),(0,i.kt)("h3",{id:"help-needed"},"Help needed"),(0,i.kt)("p",null,"As things stand right now, I will not be able to get Worker to work with AutoMapper. Maybe Worker will improve in the future, maybe there's another runtime (Deno?!), or maybe there's someone that can come up with a brilliant idea, then I'll come back to getting Worker supported. Only then, we will have real Async."))}c.isMDXComponent=!0}}]);