(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[969],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return g}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),m=s(n),g=o,d=m["".concat(p,".").concat(g)]||m[g]||l[g]||a;return n?r.createElement(d,i(i({ref:t},u),{},{components:n})):r.createElement(d,i({ref:t},u))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},651:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var r=n(2122),o=n(9756),a=(n(7294),n(3905)),i={id:"convert-using",title:"ConvertUsing",sidebar_label:"ConvertUsing"},c={unversionedId:"mapping-configuration/convert-using",id:"mapping-configuration/convert-using",isDocsHomePage:!1,title:"ConvertUsing",description:"convertUsing() accepts a Converter interface which is an object with a convert() method.",source:"@site/docs/mapping-configuration/convert-using.md",sourceDirName:"mapping-configuration",slug:"/mapping-configuration/convert-using",permalink:"/docs/mapping-configuration/convert-using",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/mapping-configuration/convert-using.md",version:"current",sidebar_label:"ConvertUsing",frontMatter:{id:"convert-using",title:"ConvertUsing",sidebar_label:"ConvertUsing"},sidebar:"docs",previous:{title:"MapWith",permalink:"/docs/mapping-configuration/map-with"},next:{title:"NullSubstitution",permalink:"/docs/mapping-configuration/null-substitution"}},p=[{value:"Why?",id:"why",children:[]},{value:"Usage",id:"usage",children:[]},{value:"Usage without <strong>Selector</strong>",id:"usage-without-selector",children:[]}],s={toc:p};function u(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"convertUsing()")," accepts a ",(0,a.kt)("inlineCode",{parentName:"p"},"Converter")," interface which is an object with a ",(0,a.kt)("inlineCode",{parentName:"p"},"convert()")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export interface Converter<\n  TConvertSource = unknown,\n  TConvertDestination = unknown\n> {\n  convert(source: TConvertSource): TConvertDestination;\n}\n")),(0,a.kt)("h2",{id:"why"},"Why?"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Converter")," can be used to extract common logic where we want to map one data type to another. This logic might be used across different mappings across the application."),(0,a.kt)("p",null,"For example, we might have a ",(0,a.kt)("inlineCode",{parentName:"p"},"dateToStringConverter"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import type { Converter } from '@automapper/types';\n\nexport const dateToStringConverter: Converter<Date, string> = {\n  convert(source) {\n    // maybe handle validation, additional parsing, or format here\n    return source.toDateString();\n  },\n};\n")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"Beside the ",(0,a.kt)("inlineCode",{parentName:"p"},"Converter"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"convertUsing()")," accepts a second argument ",(0,a.kt)("strong",{parentName:"p"},"Selector")," to select a value from the ",(0,a.kt)("strong",{parentName:"p"},"Source"),". The return type of this ",(0,a.kt)("strong",{parentName:"p"},"Selector")," needs to match the data type of the ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Converter"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { convertUsing } from '@automapper/core';\n\nmapper.createMap(User, UserDto).forMember(\n  (destination) => destination.birthday,\n  convertUsing(dateToStringConverter, (source) => source.birthday)\n);\n")),(0,a.kt)("h2",{id:"usage-without-selector"},"Usage without ",(0,a.kt)("strong",{parentName:"h2"},"Selector")),(0,a.kt)("p",null,"We can have ",(0,a.kt)("inlineCode",{parentName:"p"},"Converter#convert")," takes in the whole ",(0,a.kt)("strong",{parentName:"p"},"Source")," object as its argument. If we have these types of ",(0,a.kt)("inlineCode",{parentName:"p"},"Converter"),", we do not need to pass in the ",(0,a.kt)("strong",{parentName:"p"},"Selector")," because the whole ",(0,a.kt)("strong",{parentName:"p"},"Source")," object will be passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"Converter#convert")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export const fullNameConverter: Converter<User, string> = {\n  convert(source) {\n    return source.firstName + ' ' + source.lastName;\n  },\n};\n\nimport { convertUsing } from '@automapper/core';\n\nmapper\n  .createMap(User, UserDto)\n  .forMember(\n    (destination) => destination.fullName,\n    convertUsing(fullNameConverter)\n  );\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"convertUsing()")," will set the ",(0,a.kt)("inlineCode",{parentName:"p"},"TransformationType")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"TransformationType.ConvertUsing")))}u.isMDXComponent=!0}}]);